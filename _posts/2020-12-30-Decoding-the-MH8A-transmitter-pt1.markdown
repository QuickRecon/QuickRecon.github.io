---
layout: post
title:  "Decoding the MH8A transmitter (Part 1)"
date:   2020-12-30 18:50:27 +0800
categories: MH8A
excerpt_separator: <!--more-->
---

So one of the more interesting modern(ish) developments in dive equipment has been
the invention of AI, as in air integration, you'd be hard-pressed to get tensorflow
running underwater. Basically instead of using an analog pressure gauge, a pressure
transducer in the dive computer reads the pressure of the gas in the tank and displays
it. It also allows for you to do all kinds of fancy maths to work out the estimated time
left in the tank, and record the divers consumption rate for post dive analysis.

On its own this is cool, but not quite as cool as what happened next, *wireless* air integration.
Some very clever people managed to work out how to send a radio signal through water, which has traditionally
only been done by [large governments trying to talk to their submarines][submarines], but now anyone with a
few hundred dollars to drop on a transmitter can do the same (assuming they already have a computer capable of receiving
the signal).

I've had a dive computer capable of receiving these signals (A Shearwater Perdix AI for those playing along at home)
for quite some time, and while I don't intend to use it as transmitters are expensive and aren't ideal for the 
kind of diving I do, I've wondered if I can use the recieving hardware for other things, such as the battery status
of my scooter. To do this the first step would be to decode the protocol and work out exactly how the data is being sent, 
and how to send my own data.
<!--more-->
I'm very thankful that one of my friends was willing to lend me a transmitter to take some measurements/observations of
what gets transmitted, however this also meant that I could not physically open it to look at how the RF circuitry is
designed.

The only place I could really start was in the name, a number of different brands, including Aqualung, Shearwater, and
Oceanic all use the same transmitter manufactured by Pelagic Pressure Systems, and they are commonly known as the MH8A
transmitter, after the FCC ID. Some research of this ID lead me to the [related FCC documentation][fccid], and while the
documentation gives disappointingly few details about the protocol, it does list the frequency transmitted: 38KHz

# Collection of data
This makes sense as longer wavelengths (for radio stuff at least) attenuate slower in water, however this is far too low
to be received by my RTL-SDR in any sane configuration, so actually receiving the packets proved challenging. What I 
ended up doing was using my oscilloscope with the probe looped around the transmitter and recording CSVs of the captured
signal. What I ended up capturing was this:

![Digital packet on oscilloscope screen](/assets/Shearwater Decode/packet.png "I'm sorry about hasty phone images but I'm between labs and didn't take screenshots at the time")

There definitely appears to be some structure there, zooming in we find that 38KHz signal we were promised in the FCC
filings:
![Zoomed in image of previous packet](/assets/Shearwater Decode/bursts.png "This is literally just the same capture zoomed in, so there is some aliasing shenanigans afoot, its 38KHz at its core")

Now pictures of an oscilloscope are very nice and pretty, but don't actually help us decode the packets, for that we need
to convert these squiggly lines into usable 1s and 0s. Looking closely at the first image we can see that while the bursts
themseves look to be equal in size, the space between them changes, to decode this I wrote a matlab program to take in CSVs
copied from the scope via a usb stick. The code I used is as follows (excluding matlabs autogenerated CSV stuff,
and some additional commenting):
{% highlight matlab %}
secondVec = table2array(data(:,"Second"));
signalVec = table2array(data(:,"Volt"));

% Convert to binary-ish by looking at when measured voltage is greater than a threshold
for i = 1:length(signalVec)
    if abs(signalVec(i)) > 0.02
        decodeVec(i) = 1;
    else
        decodeVec(i) = 0;
    end
end

% Filter out the crap/denoise the signal by correcting isolated 0s in the middle of packets.
% This is an artifact of the 38KHz oscillations within each burst, the 0 crossing point registers as a single 0 entry.
for runs = 1:3
    for i = 3:(length(decodeVec)-3)
        if (decodeVec(i-1) == 1 || decodeVec(i-2) == 1) &&  (decodeVec(i+1) == 1 || decodeVec(i+2) == 1)
            decodeVec(i)=1;
        end
    end
end

% Decode the Binary by looping over the de-crapped signal and recording the number of points (essentially the time)
% between pulses.
binaryIndex = 0;
decodeIndex = 1;
while decodeIndex <= length(decodeVec)
    if decodeVec(decodeIndex) == 0
        binaryIndex = binaryIndex + 1;
        time = 0;
        while decodeVec(decodeIndex) == 0 && decodeIndex < length(decodeVec)
            time = time + 1;
            decodeIndex = decodeIndex + 1;
        end
        binaryTime(binaryIndex) = time;
        decodeIndex = decodeIndex + 1;
    else
        decodeIndex = decodeIndex + 1;
    end
end

% Convert into a final binary number by applying a threshold to the times.
for i = 2:(length(binaryTime)-1) % The first and last entries are massive, because they are before and after the signal
                                 % so we ignore those
    if binaryTime(i) > 80
        binary(i) = 1;
    else
        binary(i) = 0;
    end
end

% Here is where I extracted various parts of data from the code, like the real time between points, plot various things,
% and display the final binary packet, to keep things simple I'm just gonna display the final packet.
disp binary;
{% endhighlight %}

# Decoding the structure
Pardon my code quality, it was written at some point between midnight and 3am on one of the many late nights I spent
working on this. Plotting the time between pulses we can see there is a definite pattern:

![Graph of time between pulses](/assets/Shearwater Decode/binaryTime.png "matlab go brrrrrr")

I should be clear that this didn't just sort of happen, there was a lot of screwing around with endian-ness, order,
comparison against somewhat standard modulation techniques, and other such things, and this is what dropped out. I'm
glossing over all the red herrings.

Long story short a packet coming out of the transmitter looks a little something like this:

```
0010000001101010100011101110011110001101100111000001010010
```

This on its own is, gently put, challenging. its 58 bits long, and as one contiguous block gives very little in the way
of structure. There are a couple of key observations that can be made that helps us, firstly if we gather multiple
packets by the same method a pattern does start to emerge (labeled with the PSI pressure the packet was sampled at):

```
1742: 0010000001101010100011101110011110001101100111000001010010 
1748: 0010000001101010100011101110011110001101101010000001010101 
1746: 0010000001101010100011101110011110001101101001000001010100 
1732: 0010000001101010100011101110011110001101100010000001001101 
 544: 0010000001101010100011101110011110000100010000000001000100 
 792: 0010000001101010100011101110011110000110001100000001010111 
 438: 0010000001101010100011101110011110000011011011000001011010
   0: 0010000001101010100011101110011110000000000000000001000010
1582: 0010000001101010100011101110011110001100010111000001001101
1578: 0010000001101010100011101110011110001100010101000001001011
```

Looking at this we can see there is a definite point where there is a changing section and a static section:
```
1742: 0010000001101010100011101110011110 001101100111000001010010 
1748: 0010000001101010100011101110011110 001101101010000001010101 
1746: 0010000001101010100011101110011110 001101101001000001010100 
1732: 0010000001101010100011101110011110 001101100010000001001101 
 544: 0010000001101010100011101110011110 000100010000000001000100 
 792: 0010000001101010100011101110011110 000110001100000001010111 
 438: 0010000001101010100011101110011110 000011011011000001011010
   0: 0010000001101010100011101110011110 000000000000000001000010
1582: 0010000001101010100011101110011110 001100010111000001001101
1578: 0010000001101010100011101110011110 001100010101000001001011
```
Then by looking specifically at the 0 pressure entry, we can see there is a non-zero component at the end, likely a 
checksum, and there is always this set of static 0s with a 1, likely some kind of status or separator section. Applying
this further subdivision we find:
```
1742: 0010000001101010100011101110011110 001101100111 000001 010010 
1748: 0010000001101010100011101110011110 001101101010 000001 010101 
1746: 0010000001101010100011101110011110 001101101001 000001 010100 
1732: 0010000001101010100011101110011110 001101100010 000001 001101 
 544: 0010000001101010100011101110011110 000100010000 000001 000100 
 792: 0010000001101010100011101110011110 000110001100 000001 010111 
 438: 0010000001101010100011101110011110 000011011011 000001 011010
   0: 0010000001101010100011101110011110 000000000000 000001 000010
1582: 0010000001101010100011101110011110 001100010111 000001 001101
1578: 0010000001101010100011101110011110 001100010101 000001 001011
```

# Decoding the pressure
To further understand whats going on here we must do the thing that I avoid in almost all circumstances, read the
[manual][manual]. More specifically we're looking at the specifications to see what the resolution is, as this is almost
certainly going to be the resolution in which the data is sent:

![Shearwater perdix AI transmitter specifications](/assets/Shearwater Decode/specs.png "Always remember to RTFM")

Bingo, 2 PSI/1 Bar.

After going down the rabbit hole of assuming its 1 bar resolution and being disappointed, we can start decoding using a 
2 PSI resolution. As the pressure is probably stored as a binary integer with a "resolution" of 1, a 2 PSI resolution
would imply that they are sending over *half* the pressure value, and if we take the last entry from our list of packets:
1578 PSI, and convert half of that to a binary integer we find:
```
1578/2 = 789
789 => binary = 1100010101
              = 001100010101 (add some 0 padding)
```
As can be seen this exactly matches the second binary block we identified before, we now know how the pressure is stored.

# The checksum
There is also whatever is going on in that last non-static binary block. It's pretty common in wireless communication
for there to be some kind of check sum or error correction/detection method, be it a parity bit, a hamming code, or some
other method of detecting something has changed and fixing it. This is also what is going on here, this final block is a
function of the pressure. Firstly I checked all of the common error codes in use today, as there is enough space in that
blob to fit a "detect 2, fix 1" method, however no luck. I was going to need to do this the old fashioned way.

So I did what any physics student would do when faced with a dataset that *should* have a trend in it, throw that shit into
excel (or in my case libreoffice) and chuck trendlines at it:

![Spreadsheet showing linear relationship](/assets/Shearwater Decode/spreadsheet.png "NGL R=1 feels more suspicious than R=0.98534234243...")

Oh

It's linear?

This raised many questions, including those about my sanity, spoiler warning, its not linear. However I knew I was going to need more data, and collecting
it by hand was going to be a massive pain.

# Collection of data 2: Automation boogaloo
It was at this point I remembered my oscilloscope had a USB port, and spent far too long trying to get that to work. Then
I remembered my oscilloscope also had a LAN port, and spent far too long trying to get that to work, but then actually 
getting it to work. It uses VXI-11, which of course has a python library (there is also a matlab toolbox but it refused
to work properly under linux so python it is), so after importing `vxi11` and doing some more midnight smashing of my face
into the keyboard I made this script:

{% highlight python %}
import vxi11
import time

# Parameters
voltage_threshold = 0.02
filter_runs = 3
timing_threshold = 80


def parse_siglent_csv(raw_data):
    lines = raw_data.split("\n")
    i = 0
    scope_signal = []
    point_time = []
    for line in lines:
        point = line.split(',')
        if point[0] == '':
            scope_signal.append(point[4])
            point_time.append(point[3])
    return point_time, scope_signal


def decode_binary(scope_signal):
    decode_signal = []
    # Convert to Binary-ish
    for i in range(0, len(scope_signal)):
    if abs(float(scope_signal[i])) > voltage_threshold:
        decode_signal.append(1)
    else:
        decode_signal.append(0)

    # Filter out the crap
    for _ in range(0, filter_runs):
        for i in range(2, len(decode_signal) - 2):
            if (decode_signal[i - 1] == 1 or decode_signal[i - 2] == 1) and (
                    decode_signal[i + 1] == 1 or decode_signal[i + 2] == 1):
                decode_signal[i] = 1

    # Decode to space timings
    decode_index = 0
    binary_time = []
    while decode_index <= len(decode_signal) - 1:
        if decode_signal[decode_index] == 0:
            t = 0
            while decode_index < len(decode_signal) and decode_signal[decode_index] == 0:
                t += 1
                decode_index += 1
            binary_time.append(t)
            decode_index += 1
        else:
            decode_index += 1

    binary = []
    for i in range(1, len(binary_time) - 1):
        if binary_time[i] > timing_threshold:
            binary.append(1)
        else:
            binary.append(0)

    return binary


logfile = open('logfile2.txt', 'w')

print("Connecting to OScope")
instr = vxi11.Instrument("192.168.1.169")
print(instr.ask("*IDN?"))

print("Starting Data Collection")
instr.ask("ARM")
while True:
    if instr.ask("SAST?") == "SAST Stop":
        data = instr.ask("GET_CSV?  DD,DIS,SAVE,ON")
        pointTime, signal = parse_siglent_csv(data)
        binary = decode_binary(signal)
        binary_string = ''.join(map(str, binary))
        print(binary_string)
        logfile.write(binary_string+'\n')
        instr.ask("ARM")
    else:
        time.sleep(0.5)
{% endhighlight %}

Basically it just sets the scope up to receive a packet, waits for the scope to trigger, then downloads/decodes the packet,
saving the result, and then resets the scope for the next packet. Using this I was able to record a file that contains
every single pressure/packet pair for my transmitter.

# Decoding the checksum

I then wrote another python program to read these log files and decode the pressure, check digit, and calculate my own
check digit function to compare (if you look closely at the code you can probably work out where this is going):

{% highlight python %}
import math

import matplotlib.pyplot as plt

logfile = open('logfile2.txt', 'r')

line = logfile.read()

binaries = line.split('\n')

logfile = open('logfile.txt', 'r')

line = logfile.read()

binaries += line.split('n')
values = []
checks = []
validBinaries = []
for binary in binaries:
    try:
        value = int(binary[34:46], 2)
        check = int(binary[len(binary)-5:len(binary)], 2)
        print(''.join(binary) + ', ' + str(2*value) + ': ' + str(check))
        if len(binary) == 58:
        values.append(value)
        checks.append(check)
        validBinaries.append(binary)
    except ValueError:
        print("Bad Number")

calcedChecks = []
for i in range(0,len(values)):
    calcedChecks.append(int(validBinaries[i][42:46],2)+int(validBinaries[i][38:42],2)+int(validBinaries[i][34:38],2)+2)
    if calcedChecks[i] >= 32:
        calcedChecks[i] = calcedChecks[i]-32

plt.figure(dpi=500)
plt.plot(values,checks,'o-')
plt.plot(values, calcedChecks,'.')
plt.show()
{% endhighlight %}

Just plotting the checksum with respect to the pressure gives us:
![Plot showing repeating pattern of check digit](/assets/Shearwater Decode/checksumPlot.png "Axis labels are hard")

So yeah, not linear, but its sort of maybe linear over a close region? I first started throwing various modulus expressions
at it to try and work out whats going on, when I recalled an observation I made back when decoding the pressure. The number
expressing the pressure is 12 bits long, and as we will (probably) see in part 2, the packet likes being broken up into 4 bit
words. If we break up the pressure into its 4 bit words and sum those 3 words together (as well as add 2 and truncate to
5 bits), and plot in orange with the prior plot we get:

![Similar to previous plot, showing correct overlay of calculated results](/assets/Shearwater Decode/checksumCalcedPlot.png "I know its not quite the same dataset, I took more samples in the low range]")

[wat][wat]

In my opinion the best way to describe this method of error correction would be confusing, its using 5 bits for the same
error correction power as a parity bit, and depending on how you separate off that middle blob, there is enough room for
a hamming code or similar which can not just detect but correct. If anyone knows why this method was used (or if you
can work out a better explanation for the same observations, that +2 seems way too arbitrary to me) please get in touch.

# Transmitting to the computer
As I firstly wanted to avoid getting arrested by the Feds for running a pirate radio, and secondly didn't
want to go out and buy anything, I threw together a circuit that basically uses an arduino to pulse voltage across a coil.
The schematic for the circuit is:
![Schematic of transmitter](/assets/Shearwater Decode/Transmitter Schematic.png "Making schematics look good is hard")
And diagramed on a breadboard it looks something like this:
![Diagram of transmitter](/assets/Shearwater Decode/Transmitter Diagram.png "Making diagrams look good is even harder")

Then to make it all run I have written quite possibly the most cursed arduino code ever written:
{% highlight c %}
int packetLength =  59; // Define the size of the packet we're transmitting

boolean carrierToggle = 0; // Preserve the current oscillator state between loops
String header = "0010000001101010100011101110011110";
String seperator = "0000010";
String packet; // = "00010000001101010100011101110011110001100010101000001001011"; // The binary packet to bang out
int currBit = 0;
int pressure = 1002;
boolean outputEnable=1;
long toggleAt=0;
long currTime;

// 0 time: 0.001059859550000s ~ 1ms
// 1 time: 0.002119719099999s ~ 2ms


int GenerateChecksum(int number)
{
    String num1 = String(bitRead(number,11)) + String(bitRead(number,10)) + String(bitRead(number,9)) + String(bitRead(number,8));
    String num2 = String(bitRead(number,7)) + String(bitRead(number,6)) + String(bitRead(number,5)) + String(bitRead(number,4));
    String num3 = String(bitRead(number,3)) + String(bitRead(number,2)) + String(bitRead(number,1)) + String(bitRead(number,0));

    return StrToInt(num1) + StrToInt(num2) + StrToInt(num3) + 2;
}

int StrToInt(String binWord) {
    int result=0;
    for(int i=binWord.length()-1; i >= 0; i--){
        if(binWord[binWord.length()-i-1] == '1')
        {
            bitSet(result, i);
        }
    }
    return result;
}

String IntToStr(int number, int bits) {
    String result;
    result.reserve(13);
    for(int i=bits-1; i >= 0; i--){
        result += String(bitRead(number,i));
    }
    return result;
}

void updatePacket() {
    int sendPressure = pressure/2; // Pressure is sent as half the actual value
    
    // Generate packet
    String pressureString = IntToStr(sendPressure,12);
    int checksum = GenerateChecksum(sendPressure);
    String checksumString = IntToStr(checksum,5);

    packet = header + pressureString + seperator + checksumString;
}

void setup() {
    Serial.begin(9600);
    updatePacket();
    Serial.println(packet);

    pinMode(9, OUTPUT);

    cli();//stop interrupts

    // Set up timer2
    TCCR2A = 0;// set entire TCCR2A register to 0
    TCCR2B = 0;// same for TCCR2B
    TCNT2  = 0;//initialize counter value to 0
    // set compare match register for 76.9khz increments
    OCR2A = 26;// = (16*10^6) / (8000*8) - 1 (must be <256)
    // turn on CTC mode
    TCCR2A |= (1 << WGM21);
    // Set CS21 bit for 8 prescaler
    TCCR2B |= (1 << CS21);   
    // enable timer compare interrupt
    TIMSK2 |= (1 << OCIE2A);
    currTime = micros();
    sei();//allow interrupts
}

ISR(TIMER2_COMPA_vect){
    if(outputEnable && currTime >= toggleAt) { // Handle the case of TXing to not TXing
        outputEnable = 0;
        if(currBit >= packetLength) { // Handle end of message
            pressure = pressure + 2; // Increment the pressure on every packet, wrap around if we get too big
            if(pressure > 4500) {
                pressure = 500;
            }

            updatePacket();
            currBit = 0;
            toggleAt = currTime + 6000000; // Wait 6 seconds before sending another message
        }
        else if(packet[currBit]=='0') { // Handle 0
            toggleAt = currTime + 1000; // Wait 1ms before next pulse
        }
        else { //Handle 1
            toggleAt = currTime + 2000; // Wait 2ms before next pulse
        }
    }
    else if (!outputEnable && currTime >= toggleAt) { //Handle case of not TXing to TXing
        outputEnable = 1;
        toggleAt = currTime + 1000; // Each pulse lasts 1 ms
        currBit++;
    }
    // Perform oscillation if we're enabled
    if(outputEnable)
    {
        //generates pulse wave of frequency 8kHz/2 = 4kHz (takes two cycles for full wave- toggle high then toggle low)
        if (carrierToggle){
            digitalWrite(9,HIGH);
            carrierToggle = 0;
        }
        else {
            digitalWrite(9,LOW);
            carrierToggle = 1;
        }
    }
    else { // Ensure we send the pin low if we're not TXing
        digitalWrite(9,LOW);
        carrierToggle = 1;
    }
}

void loop() {
    currTime = micros();
}
{% endhighlight %}

This code was my first real adventure into bitwise manipulation with arduino c and it is incredibly bad, do not do this.
At some point I'm going to rewrite this properly to not use string manipulation to control the bits, it can all be done
with `bitset` for much lower overhead. Also a word of warning for anyone who is mad enough to try to use this code, the
runtime of the interrupt is *very* close to the period of the interrupt, so adding any additional code can cause it to 
lock up, which can burn out the PN2222 transistor.

As incredibly cursed as this code is, we did in fact get results:
![Photo of functioning configuration](/assets/Shearwater Decode/success.jpg "If its stupid and it works, its still stupid")

As can be seen on the shearwater, T1 is showing a pressure of 1578 PSI, as sent by the arduino through the coil. Interestingly
it is also possible to send values that are outside of the expected range, for example 5000 PSI works even though the
transmitters are only speced to 4350.

![Photo of Perdix displaying 5000 PSI](/assets/Shearwater Decode/overpressure.jpg "I wonder if I can buffer overflow it?")

However there is a limit, as 8000 PSI (still within the 12 bit limit) did not work, 
so more work is needed on this.

# More work
There are still quite a few unanswered questions before I can call the transmitter fully decoded, for one I'm currently 
restricted to only the transmitter ID I have captured a heading for. I have a couple ideas as to how the header is formed,
breaking up the header into 4 bit words moving right to left and decoding we find:
```
0010000001 1010 1010 0011 1011 1001 1110
 unknown?   10   10    3   11    9   14
```

The sequence 10 10 3 11 9 14 is quite similar to the actual TX-ID of the transmitter used, 0 0 3 1 9 8. Perhaps the binary
for 0, 1 and 8 have been substituted for some reason? I also don't know if there is some checksum for TX-ID as the existing
scheme only checks pressure, maybe in that unknown blob at the start?

There is also the case of how the battery levels are encoded, as in the specs it is mentioned that low and critical battery
alarms are displayed when the transmitter battery gets below certain thresholds. I've observed no indication of anything
pointing to transmitting the actual battery voltage, so there must be some status word transmitted, perhaps in the block 
between the pressure and its checksum?

There are still many things to try and work out, both on the software/decode front, and on the transmitter front, as the
current configuration has highly limited range of about 30cm, compared to the 1m of the real deal, and my version is also
highly directional due to the primarily magnetic emission. Hopefully I'll be able to write another entry detailing
these potential new avenues for discovery.

[manual]: https://www.shearwater.com/wp-content/uploads/2020/03/PerdixAI_Operating_Instructions_RevC.pdf
[submarines]: https://en.wikipedia.org/wiki/Naval_Communication_Station_Harold_E._Holt
[fccid]: https://fccid.io/MH8A
[wat]: https://www.destroyallsoftware.com/talks/wat